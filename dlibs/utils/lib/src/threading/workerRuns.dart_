import 'dart:isolate' show Isolate, ReceivePort, SendPort;

import 'messages.dart';
import 'threading.dart';

typedef Future WorkerRun2(Worker self, Msg input);
typedef Future WorkerRun1(Worker self, Stream<Msg> stream);
typedef Future WorkerInitThread(Worker self);

Future<Isolate> startWorker(Worker proxy) async {
  final isolate = await Isolate.spawn(
      proxy.entryPoint, proxy.createMsg(WorkerInit.encode(proxy.initPar)));
  isolate.addOnExitListener(proxy.receivePort.sendPort,
      response: proxy.createMsg(WorkerFinished.encode()));
  return Future.value(isolate);
}

void _exampleEntryPoint(List workerInitMsg) {
  // static init thread
  final worker = Worker.worker(workerInitMsg);
  workerRun1(worker, (self, msg) => null);
}

void workerRun0(Worker self, WorkerRun1 workerRun1,
        [WorkerInitThread init]) async =>
    _workerRun0(self, workerRun1, init);
Future workerRun1(Worker self, WorkerRun2 workerRun2,
        [WorkerInitThread init]) async =>
    _workerRun0(
        self, (self, stream) => _workerRun1(self, stream, workerRun2), init);

void _workerRun0(
    Worker self, WorkerRun1 workerRun1, WorkerInitThread initThread) async {
  try {
    initMessages();
    initThread(self);
    if (trace) print('WORKER START: $self.id');
    // notify pool
    self.sendMsg(WorkerStartedMsg.encode());
    // listen to stream
    final stream = self.receivePort.map((list) => decodeMessage(list) as Msg);
    await workerRun1(self, stream);
  } catch (exp, stacktrace) {
    print(exp.toString());
    print(stacktrace.toString());
    self.sendMsg(ErrorMsg.encode(exp.toString(), stacktrace.toString()));
  }
  self.receivePort.close();
}

//Future (Msg msg) async {}
Future _workerRun1(Worker self, Stream<Msg> stream, workerRun2) async {
  await for (final msg in stream) {
    try {
      if (trace) print('WORKER MSG: ${self.id}-$msg');
      if (msg is FinishWorker) break;
      await workerRun2(self, msg);
    } catch (exp, stacktrace) {
      self.sendError(exp, stacktrace);
    }
  }
}
